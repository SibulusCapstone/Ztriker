
/*
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/b361d206-c2f0-4b16-b0e8-ddf91792e2df

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float BO;
  int strikeCounter;
  float latestStrikeForceFloat;
  float latestStrikeSpeedFloat;
  float averageStrikeForce;
  float averageStrikeSpeed;
  float conf;
  float state;
  int lEDState;
  float HR;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch. 
*/

#include "thingProperties.h"

#include <Arduino_MeasurementUnit.h>
#include <ArduinoBLE.h>
#include <string>
#include <stdio.h>


#include <SparkFun_Bio_Sensor_Hub_Library.h>
#include <Wire.h>

// Reset pin, MFIO pin
int resPin = 2;
int mfioPin = 3;
// Takes address, reset pin, and MFIO pin.
SparkFun_Bio_Sensor_Hub bioHub(resPin, mfioPin);
bioData body;

//RGB LED 1
int redPin = 9;
int greenPin = 6;
int bluePin = 5;
int delayChange = 5;  // in ms, how long to delay each loop of brightness change
int loopDelta = 1;    // how much to change brightness each loop
int ledLow = 0;       // lowest value for each LED
int ledHigh = 150;    // highest value for each color
int invertColor(int color) {
  return (color * -1) + 255;
}
int brightness = 220;    // how bright the LED is
int fadeAmount = 5;    // how many points to fade the LED by

unsigned long startTime = micros();
float xA, yA, zA;
float yG, zG, xG;
//float HR;
//float BO, conf, state;
float TotalA;
char buffer[200];
int16_t data[6];

// DELTA ARRAYS
int16_t Xacceldelta[3];
int16_t Yacceldelta[3];
int16_t Zacceldelta[3];
int16_t TotalAccelDelta[3];
int16_t Xgyrodelta[3];
int16_t Ygyrodelta[3];
int16_t Zgyrodelta[3];
int timebetweenhits[2] = {0, 0};
int16_t latestStrikeForce[2] = {0, 0};
int16_t latestStrikeSpeed[2] = {0, 0};

//float latestStrikeForceFloat;
//float latestStrikeSpeedFloat;

//float averageStrikeForce ;
//float averageStrikeSpeed ;

float toAccel = 0.00479;
float toGyro = 2000 / 32768;

//Button settings for start/stop recording

int LEDState = 0;
int LEDPin = 13;
int buttonPin = 12;
int buttonNew;
int buttonOld = 1;
int dt = 100;
int recordingState;
//int strikeCounter = 0;
unsigned long lastrecordedTime;
unsigned long elapsedTime;
unsigned long previousLEDTime = 0;
unsigned long LEDTime;




void setup() {
  startTime = micros();
  // Initialize serial and wait for port to open:
// Serial.begin(115200);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
  pinMode(buttonPin, INPUT);
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(redPin, OUTPUT);
  pinMode(greenPin, OUTPUT);
  pinMode(bluePin, OUTPUT);
  digitalWrite(redPin, HIGH);
  digitalWrite(bluePin, HIGH);
  digitalWrite(greenPin, HIGH);
  pinMode(LEDPin, OUTPUT);
  pinMode(buttonPin, INPUT);

  // put your setup code here, to run once:
  Wire.begin();
  int result = bioHub.begin();
//  if (result == 0) // Zero errors!
//    Serial.println("Sensor started!");
 // else
 //   Serial.println("Could not communicate with the sensor!!!");
//  Serial.println("Configuring Sensor....");
  int error = bioHub.configBpm(MODE_ONE); // Configuring just the BPM settings.
 // if (error == 0) { // Zero errors!
 //   Serial.println("Sensor configured.");
 // }
 // else {
 //   Serial.println("Error configuring sensor.");
 //   Serial.print("Error: ");
 //   Serial.println(error);
//  }

  // Data lags a bit behind the sensor, if you're finger is on the sensor when
  // it's being configured this delay will give some time for the data to catch
  // up.
 // Serial.println("Loading up the buffer with data....");
  //HR sensor setup end


  if (!IMU.begin()) {
//    Serial.println("Failed to initialize IMU!");
    while (1);
  }
//  Serial.println("IMU set up");
  previousLEDTime = micros() - startTime; 
}



void loop() {
  ArduinoCloud.update();
  checkButtonState();
    if (LEDState == 0) {
    LEDTime = micros() - startTime;
    if ((LEDTime-previousLEDTime) < 500000) {
    analogWrite(redPin, 256);
    analogWrite(bluePin, 220);
    analogWrite(greenPin, 256);
    checkButtonState();
    LEDTime = micros() - startTime;
    }
    if (((LEDTime-previousLEDTime) >= 500000) && ((LEDTime-previousLEDTime) <= 2300000)) {
    analogWrite(redPin, 256);
    analogWrite(bluePin, 256);
    analogWrite(greenPin, 256); 
    LEDTime = micros() - startTime;
    }
    if (( (LEDTime-previousLEDTime) > 2300000)) {
    previousLEDTime = LEDTime; 
    }
    checkButtonState();
  }
  if (LEDState == 1) {
    analogWrite(redPin, 256);
    analogWrite(bluePin, 256);
    analogWrite(greenPin, 220);
    readIMU();
    Xacceldelta[0] = data[0];
    Yacceldelta[0] = data[1];
    Zacceldelta[0] = data[2];
    Xgyrodelta[0] = data[3];
    Ygyrodelta[0] = data[4];
    Zgyrodelta[0] = data[5];
    TotalAccelDelta[0] = sqrt(sq(data[0]) + sq(data[1]) + sq(data[2]));
    //Read and save IMU values to second slot in Delta arrays
    readIMU();
    Xacceldelta[1] = data[0];
    Yacceldelta[1] = data[1];
    Zacceldelta[1] = data[2];
    Xgyrodelta[1] = data[3];
    Ygyrodelta[1] = data[4];
    Zgyrodelta[1] = data[5];
    TotalAccelDelta[1] = sqrt(sq(data[0]) + sq(data[1]) + sq(data[2]));
    readIMU();
    Xacceldelta[2] = data[0];
    Yacceldelta[2] = data[1];
    Zacceldelta[2] = data[2];
    Xgyrodelta[2] = data[3];
    Ygyrodelta[2] = data[4];
    Zgyrodelta[2] = data[5];
    TotalAccelDelta[2] = sqrt(sq(data[0]) + sq(data[1]) + sq(data[2]));
    checkButtonState();
  }

  while (LEDState == 1) {
      
    
    for (int i = 0; i <= 300; i++) {
      
      lastrecordedTime = elapsedTime ;
      unsigned long elapsedTime = micros() - startTime;
      readIMU();
      //updating BLE values

      Xacceldelta[2] = Xacceldelta[1];
      Yacceldelta[2] = Xacceldelta[1];
      Zacceldelta[2] = Xacceldelta[1];
      Xgyrodelta[2] = Xacceldelta[1];
      Ygyrodelta[2] = Xacceldelta[1];
      Zgyrodelta[2] = Xacceldelta[1];
      TotalAccelDelta[2] = TotalAccelDelta[1];

      Xacceldelta[1] = Xacceldelta[0];
      Yacceldelta[1] = Xacceldelta[0];
      Zacceldelta[1] = Xacceldelta[0];
      Xgyrodelta[1] = Xacceldelta[0];
      Ygyrodelta[1] = Xacceldelta[0];
      Zgyrodelta[1] = Xacceldelta[0];
      TotalAccelDelta[1] = TotalAccelDelta[0];

      Xacceldelta[0] = data[0];
      Yacceldelta[0] = data[1];
      Zacceldelta[0] = data[2];
      Xgyrodelta[0] = data[3];
      Ygyrodelta[0] = data[4];
      Zgyrodelta[0] = data[5];
      TotalAccelDelta[0] = sqrt(sq(data[0]) + sq(data[1]) + sq(data[2]));


      if ( (TotalAccelDelta[1] >= 5000) && (TotalAccelDelta[0] < TotalAccelDelta[1]) && (TotalAccelDelta[1] > TotalAccelDelta[2]) ) {

        timebetweenhits[0] = timebetweenhits[1];
        timebetweenhits[1] = elapsedTime;


        if ((timebetweenhits[1] - timebetweenhits[0]) >= 60000) {
          strikeCounter = strikeCounter + 1 ;
          latestStrikeForce [0] = latestStrikeForce [1];
          latestStrikeForce [1] = TotalAccelDelta[1] * toAccel ;
          latestStrikeForceFloat = latestStrikeForce [1];
          latestStrikeSpeed [0] = latestStrikeSpeed [1];
          latestStrikeSpeed [1] = ((latestStrikeForce [1])*(elapsedTime - lastrecordedTime) / 1000000);
          latestStrikeSpeedFloat = latestStrikeSpeed [1];
          averageStrikeForce  =  (averageStrikeForce + (latestStrikeForceFloat)) / 2  ;
          averageStrikeSpeed  =  (averageStrikeSpeed + (latestStrikeSpeedFloat)) / 2 ;
        }

        if ((timebetweenhits[1] - timebetweenhits[0] <= 60000) && ((latestStrikeForceFloat * toAccel) < (TotalAccelDelta[1]*toAccel))) {
          latestStrikeForce [0] = latestStrikeForce [1];
          latestStrikeForce[1] = TotalAccelDelta[1] * toAccel ;
          latestStrikeForceFloat = latestStrikeForce [1];
          latestStrikeSpeed [0] = latestStrikeSpeed [1];
          latestStrikeSpeed [1] = ((latestStrikeForce [1])*(elapsedTime - lastrecordedTime) / 1000000);
          latestStrikeSpeedFloat = latestStrikeSpeed [1];
          averageStrikeForce =  ((averageStrikeForce + (latestStrikeForceFloat)) / 2);
          averageStrikeSpeed  =  ((averageStrikeSpeed + (latestStrikeSpeedFloat)) / 2 );
        }
      }
      //sprintf(buffer, "%d, %.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%d,%.2f,%.2f,%.2f,%.2f, %.2f ,%.2f , %.2f, %.2f", elapsedTime, xA, yA, zA, xG, yG, zG, strikeCounter, latestStrikeSpeedFloat, averageStrikeSpeed, latestStrikeForceFloat, averageStrikeForce, state, HR, BO, conf);
      //Serial.println(buffer);
      Serial.println(elapsedTime - lastrecordedTime);
      
      LEDTime = micros() - startTime;
      if ((LEDTime-previousLEDTime) < 500000) {
      analogWrite(redPin, 256);
      analogWrite(bluePin, 256);
      analogWrite(greenPin, 220);
      checkButtonState();
      LEDTime = micros() - startTime;
      }
      if ( ((LEDTime-previousLEDTime) >= 500000) && ((LEDTime-previousLEDTime) <= 2000000) ) {
      analogWrite(redPin, 256);
      analogWrite(bluePin, 256);
      analogWrite(greenPin, 256);
      checkButtonState();
      LEDTime = micros() - startTime;
      }
      if (( (LEDTime-previousLEDTime) > 2000000)) {
      previousLEDTime = LEDTime; 
      }
      checkButtonState();
    }
    readHR();
    checkButtonState();
    ArduinoCloud.update();
  }
}




void readIMU() {
  unsigned long elapsedTime = micros() - startTime;
  IMU.readRegisters(0x22, (uint8_t*)data, sizeof(data));
  xA = data[0];
  yA = data[1];
  zA = data[2];
  xG = data[3];
  yG = data[4];
  zG = data[5];
}


void readHR() {
  body = bioHub.readBpm();
  delay(8);
  if (body.heartRate > 0 ) {
    HR = body.heartRate;
  }
  if (body.oxygen > 0 ) {
    BO = body.oxygen;
  }
  conf = body.confidence;
  state = body.status;
  // Serial.println(HR);
}


void checkButtonState() {
  buttonNew = digitalRead(buttonPin);
  if (buttonOld == 0 && buttonNew == 1) {
    if (LEDState == 0) {
      digitalWrite(LEDPin, HIGH);
      LEDState = 1;
    }
    else {
      digitalWrite(LEDPin, LOW);
      LEDState = 0;
    }
  }
  buttonOld = buttonNew;
  recordingState = LEDState; 
  delay(1);
}
